{"version":3,"file":"main.js","sources":["../src/utils/processSchema.ts","../node_modules/vuelidate/lib/withParamsBrowser.js","../node_modules/vuelidate/lib/withParams.js","../node_modules/vuelidate/lib/validators/common.js","../node_modules/nanoclone/index.js","../node_modules/vuelidate/lib/validators/required.js","../node_modules/vuelidate/lib/validators/minLength.js","../node_modules/vuelidate/lib/validators/maxLength.js","../node_modules/vuelidate/lib/validators/minValue.js","../node_modules/vuelidate/lib/validators/maxValue.js","../src/utils/setValidators.ts","../src/utils/mergeDeep.ts","../src/utils/processConditions.ts","../src/JsonSchema/JsonSchema.vue","../src/utils/unrefSchema.ts","../src/App.vue","../src/main.ts"],"sourcesContent":["import { JSONSchema7 } from 'json-schema'\nimport { ISchema, IUiSchema, ComponentsConfig } from '@/types'\nimport { getComponent } from './getComponent'\n\nexport const processSchema = (schema: JSONSchema7) : ISchema => {\n  const strippedSchema : any = {\n    ...schema,\n    type: (schema.type !== 'null' && ((typeof schema.type) !== 'object')) ? schema.type : 'string'\n  }\n\n  if (schema.properties) {\n    strippedSchema.properties = {}\n\n    Object.entries(schema.properties).forEach(([propName, propSchema]) => {\n      strippedSchema.properties[propName] = processSchema(propSchema as JSONSchema7)\n    })\n  }\n\n  if (schema.items) strippedSchema.items = processSchema(schema.items as JSONSchema7)\n\n  return strippedSchema\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withParams = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar root = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};\n\nvar fakeWithParams = function fakeWithParams(paramsOrClosure, maybeValidator) {\n  if (_typeof(paramsOrClosure) === 'object' && maybeValidator !== undefined) {\n    return maybeValidator;\n  }\n\n  return paramsOrClosure(function () {});\n};\n\nvar withParams = root.vuelidate ? root.vuelidate.withParams : fakeWithParams;\nexports.withParams = withParams;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar withParams = process.env.BUILD === 'web' ? require('./withParamsBrowser').withParams : require('./params').withParams;\nvar _default = withParams;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"withParams\", {\n  enumerable: true,\n  get: function get() {\n    return _withParams.default;\n  }\n});\nexports.regex = exports.ref = exports.len = exports.req = void 0;\n\nvar _withParams = _interopRequireDefault(require(\"../withParams\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar req = function req(value) {\n  if (Array.isArray(value)) return !!value.length;\n\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  if (value === false) {\n    return true;\n  }\n\n  if (value instanceof Date) {\n    return !isNaN(value.getTime());\n  }\n\n  if (_typeof(value) === 'object') {\n    for (var _ in value) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return !!String(value).length;\n};\n\nexports.req = req;\n\nvar len = function len(value) {\n  if (Array.isArray(value)) return value.length;\n\n  if (_typeof(value) === 'object') {\n    return Object.keys(value).length;\n  }\n\n  return String(value).length;\n};\n\nexports.len = len;\n\nvar ref = function ref(reference, vm, parentVm) {\n  return typeof reference === 'function' ? reference.call(vm, parentVm) : parentVm[reference];\n};\n\nexports.ref = ref;\n\nvar regex = function regex(type, expr) {\n  return (0, _withParams.default)({\n    type: type\n  }, function (value) {\n    return !req(value) || expr.test(value);\n  });\n};\n\nexports.regex = regex;","'use strict';\n\n// ES6 Map\nvar map;\ntry {\n  map = Map;\n} catch (_) { }\nvar set;\n\n// ES6 Set\ntry {\n  set = Set;\n} catch (_) { }\n\nfunction baseClone (src, circulars, clones) {\n  // Null/undefined/functions/etc\n  if (!src || typeof src !== 'object' || typeof src === 'function') {\n    return src\n  }\n\n  // DOM Node\n  if (src.nodeType && 'cloneNode' in src) {\n    return src.cloneNode(true)\n  }\n\n  // Date\n  if (src instanceof Date) {\n    return new Date(src.getTime())\n  }\n\n  // RegExp\n  if (src instanceof RegExp) {\n    return new RegExp(src)\n  }\n\n  // Arrays\n  if (Array.isArray(src)) {\n    return src.map(clone)\n  }\n\n  // ES6 Maps\n  if (map && src instanceof map) {\n    return new Map(Array.from(src.entries()))\n  }\n\n  // ES6 Sets\n  if (set && src instanceof set) {\n    return new Set(Array.from(src.values()))\n  }\n\n  // Object\n  if (src instanceof Object) {\n    circulars.push(src);\n    var obj = Object.create(src);\n    clones.push(obj);\n    for (var key in src) {\n      var idx = circulars.findIndex(function (i) {\n        return i === src[key]\n      });\n      obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);\n    }\n    return obj\n  }\n\n  // ???\n  return src\n}\n\nfunction clone (src) {\n  return baseClone(src, [], [])\n}\n\nmodule.exports = clone;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = require(\"./common\");\n\nvar _default = (0, _common.withParams)({\n  type: 'required'\n}, _common.req);\n\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = require(\"./common\");\n\nvar _default = function _default(length) {\n  return (0, _common.withParams)({\n    type: 'minLength',\n    min: length\n  }, function (value) {\n    return !(0, _common.req)(value) || (0, _common.len)(value) >= length;\n  });\n};\n\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = require(\"./common\");\n\nvar _default = function _default(length) {\n  return (0, _common.withParams)({\n    type: 'maxLength',\n    max: length\n  }, function (value) {\n    return !(0, _common.req)(value) || (0, _common.len)(value) <= length;\n  });\n};\n\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = require(\"./common\");\n\nvar _default = function _default(min) {\n  return (0, _common.withParams)({\n    type: 'minValue',\n    min: min\n  }, function (value) {\n    return !(0, _common.req)(value) || (!/\\s/.test(value) || value instanceof Date) && +value >= +min;\n  });\n};\n\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = require(\"./common\");\n\nvar _default = function _default(max) {\n  return (0, _common.withParams)({\n    type: 'maxValue',\n    max: max\n  }, function (value) {\n    return !(0, _common.req)(value) || (!/\\s/.test(value) || value instanceof Date) && +value <= +max;\n  });\n};\n\nexports.default = _default;","import required from 'vuelidate/lib/validators/required'\nimport minLength from 'vuelidate/lib/validators/minLength'\nimport maxLength from 'vuelidate/lib/validators/maxLength'\nimport minValue from 'vuelidate/lib/validators/minValue'\nimport maxValue from 'vuelidate/lib/validators/maxValue'\n\nimport { ISchema } from '@/types'\n\nexport const setValidators = (schema: ISchema) : any => {\n  const validations : any = {}\n\n  if (schema.properties) {\n    Object.keys(schema.properties).forEach((property) => {\n      const propertyObject : any = (schema.properties as any)[property]\n\n      validations[property] = {}\n\n      // requireds\n      if ((propertyObject.type === 'string' && propertyObject.minLength) ||\n          (propertyObject.type === 'number' && propertyObject.minimum) ||\n          (propertyObject.type === 'integer' && propertyObject.minimum) ||\n          (propertyObject.type === 'array' && propertyObject.minLength)) {\n        validations[property].required = required\n      }\n\n      if (propertyObject.minLength) validations[property].minLength = minLength(propertyObject.minLength)\n\n      if (propertyObject.maxLength) validations[property].maxLength = maxLength(propertyObject.maxLength)\n\n      if (propertyObject.minimum) validations[property].minValue = minValue(propertyObject.minimum)\n\n      if (propertyObject.maximum) validations[property].maxValue = maxValue(propertyObject.maximum)\n\n      // set nested validators\n      if (propertyObject.type === 'object') validations[property] = setValidators(propertyObject)\n\n      // if (propertyObject.format === 'phone') validations[property].phone = correctPhone(propertyObject)\n\n      // set item validators for array of objects\n      if (propertyObject.type === 'array' && propertyObject.items && propertyObject.items.type === 'object') {\n        validations[property] = {\n          ...validations[property],\n          $each: setValidators(propertyObject.items)\n        }\n      }\n    })\n  }\n\n  return validations\n}\n","import { IAnyObject } from '@/types'\n\nfunction isObject (item: any) {\n  return (item && typeof item === 'object' && !Array.isArray(item))\n}\n\nexport function mergeDeep (target: IAnyObject, ...sources: IAnyObject[]) : IAnyObject {\n  if (!sources.length) return target\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} })\n        mergeDeep(target[key], source[key])\n      } else {\n        Object.assign(target, { [key]: source[key] })\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources)\n}\n","import { ISchema, IAnyObject } from '@/types'\nimport clone from 'nanoclone'\nimport { mergeDeep } from './mergeDeep'\n\ntype AllOfCondition = {\n  allOf: Array<SimpleCondition>\n  then: IAnyObject\n}\n\ntype OneOfCondition = {\n  oneOf: Array<SimpleCondition>\n  then: IAnyObject\n}\n\ntype SimpleCondition = {\n  if: any,\n  then: IAnyObject\n}\n\ntype ICondition = SimpleCondition | AllOfCondition | OneOfCondition\n\n//  requirment types\n\ntype ConstRequirment = { const: any }\n\ntype MinLengthRequirment = { minLength: number }\n\ntype IRequirment = ConstRequirment | MinLengthRequirment\n\n// type IRequirmentTree = {\n//   properties: {\n//     [key: string]: IRequirmentTree | ConstRequirment | MinLengthRequirment\n//   },\n//   not: undefined\n// }\n\ntype IRequirmentTree = any\n\ntype BaseRequirment = {\n  not: IRequirmentTree\n} | IRequirmentTree\n\nexport const processSchemaConditions = (schema: ISchema, data: IAnyObject) => {\n  const newSchema = { ...schema }\n\n  if (schema.allOf) {\n    schema.allOf.forEach(condition => processCondition(condition, data, newSchema))\n  }\n\n  if (schema.if) processCondition(schema as SimpleCondition, data, newSchema)\n\n  Object.keys(schema.properties || {}).forEach(property => {\n    if (schema.properties && schema.properties[property].type === 'object') {\n      if (newSchema.properties && data && data[property]) newSchema.properties[property] = processSchemaConditions(schema.properties[property], data[property])\n    }\n  })\n\n  return newSchema\n}\n\nconst processCondition = (condition: SimpleCondition, data: IAnyObject, newSchema: ISchema) => {\n  // several requirments\n  if (condition.if.allOf) {\n    const requirments = condition.if.allOf\n\n    if (requirments.every((requirment: BaseRequirment) => checkRequierment(requirment, data))) {\n      applyCondition(newSchema, condition.then)\n    }\n\n    return\n  }\n\n  // needs one requirment\n  if (condition.if.oneOf) {\n    const requirments = condition.if.oneOf\n\n    if (requirments.some((requirment: BaseRequirment) => checkRequierment(requirment, data))) {\n      applyCondition(newSchema, condition.then)\n    }\n\n    return\n  }\n\n  // straighforward one requirment\n  if (checkRequierment(condition.if, data)) applyCondition(newSchema, condition.then)\n}\n\nexport const checkRequierment = (requirment: BaseRequirment, data: IAnyObject = {}) => {\n  // TODO: different types of requirments\n  // TODO: allOf, oneOf\n  // now only minLength and const are supported\n\n  let currentPath = requirment.not ? requirment.not.properties : requirment.properties\n  let currentValue = data\n  let currentParamName = Object.keys(currentPath)[0]\n\n  while (currentParamName !== 'const' && currentParamName !== 'minLength') {\n    if (typeof currentPath !== 'object') {\n      console.warn('[JSON-SCHEMA] Invalid IF condition: ', requirment)\n\n      return false\n    }\n\n    currentPath = currentPath[currentParamName]\n\n    if (currentParamName !== 'properties') {\n      if (typeof currentValue !== 'object') {\n        console.warn('[JSON-SCHEMA] Invalid IF condition: ', requirment)\n\n        return false\n      }\n\n      currentValue = currentValue[currentParamName]\n    }\n\n    currentParamName = Object.keys(currentPath)[0]\n  }\n\n  if (currentParamName === 'const') {\n    return requirment.not ? currentPath.const !== currentValue : currentPath.const === currentValue\n  }\n\n  if (currentParamName === 'minLength') {\n    return requirment.not\n      ? currentPath.minLength > (currentValue || '').length\n      : currentPath.minLength <= (currentValue || '').length\n  }\n\n  // return false\n}\n\nconst applyCondition = (schema: ISchema, then: IAnyObject) => {\n  return mergeDeep(schema, then)\n}\n","<template>\n  <JsonSchemaForm\n    :schema=\"conditionedScheema\"\n    :ui-schema=\"uiSchema\"\n    :value=\"value\"\n    :validations=\"validationErrors\"\n    @input=\"handleChange\"\n  />\n</template>\n\n<script lang=\"ts\">\nimport { Component, Prop, Vue, Mixins, Provide } from 'vue-property-decorator'\nimport { processSchema } from '../utils/processSchema'\nimport { setValidators } from '../utils/setValidators'\nimport { unrefSchema } from '../utils/unrefSchema'\nimport { generateDefaultValue } from '../utils/generateDefaultValue'\nimport { processSchemaConditions } from '../utils/processConditions'\nimport { JSONSchema7 } from 'json-schema'\nimport { ISchema, IUiSchema, IAnyObject, ComponentsConfig,\n  WrapperComponentConfig, ErrorMessagesConfig, ISchemaBase, ISchemaObject } from '@/types'\nimport JsonSchemaForm from './JsonSchemaForm.vue'\nimport { validationMixin } from 'vuelidate'\nimport clone from 'nanoclone'\n// require('purecss/build/pure-min.css')\n\n@Component({\n  mixins: [validationMixin],\n  name: 'JsonSchema',\n  components: { JsonSchemaForm },\n  validations () {\n    return { value: setValidators((this as any).processedSchema) }\n  }\n})\nexport default class JsonSchema extends Vue {\n  @Prop({ required: true }) readonly schema!: JSONSchema7\n  @Prop() readonly uiSchema!: IUiSchema\n  @Prop({ default: () => ({}) }) readonly value!: IAnyObject\n  @Prop() readonly components!: ComponentsConfig\n  @Prop() readonly wrapperComponentConfig!: WrapperComponentConfig\n  @Prop() readonly errorMessagesConfig!: ErrorMessagesConfig\n\n  @Provide() componentsConfig = this.components\n  @Provide() wrapperComponent = this.wrapperComponentConfig\n\n  get validationErrors () {\n    return (this as any).$v.value\n  }\n\n  created () {\n    this.$emit('init-default', generateDefaultValue(this.processedSchema))\n  }\n\n  handleChange ({ path, value } : { path: Array<string>, value: any }) {\n    const newValue = { ...this.value }\n    const paramName = path.pop() || ''\n\n    let target = newValue\n    path.forEach(paramName => {\n      if (!target[paramName]) target[paramName] = {}\n      target = target[paramName]\n    })\n\n    target[paramName] = value\n\n    this.$emit('input', newValue)\n  }\n\n  get processedSchema () : ISchema {\n    return processSchema(this.schema)\n  }\n\n  get unreffedSchema () {\n    return unrefSchema(this.schema as ISchemaObject)\n  }\n\n  get conditionedScheema () : ISchema {\n    return processSchemaConditions(clone(this.unreffedSchema), this.value)\n  }\n}\n</script>\n","import clone from 'nanoclone'\nimport { ISchema, ISchemaObject, IDefinition } from '@/types'\nimport { JSONSchema7 } from 'json-schema'\n\nexport const unrefSchema = (schema: ISchemaObject) => {\n  function getSchemaByRef (ref: string) : ISchema {\n    const refName = ref.substring(ref.lastIndexOf('/') + 1)\n\n    if (!definitionNames.includes(refName)) console.warn(`[JSON-SCHEMA] Ref=\"${ref}\" not found in definitions`)\n\n    return !definitionNames.includes(refName) ? { type: 'string' } : clone(definitions[refName])\n  }\n\n  function checkSchemaForRefs (schema: ISchemaObject) : ISchemaObject {\n    const newSchema = { ...schema }\n\n    // unref properties\n    if (newSchema.properties) {\n      Object.keys(newSchema.properties).forEach(propertyName => {\n        if (newSchema.properties[propertyName].$ref) {\n          const definedSchema = getSchemaByRef(newSchema.properties[propertyName].$ref as string)\n\n          newSchema.properties[propertyName] = {\n            ...newSchema.properties[propertyName],\n            ...definedSchema\n          }\n        }\n\n        if (newSchema.properties[propertyName].type === 'array' &&\n          newSchema.properties[propertyName].items\n        ) {\n          // if (!newSchema.properties[propertyName].items) return\n          const definedSchema = newSchema.properties[propertyName] && newSchema.properties[propertyName].items && (newSchema.properties[propertyName].items as any).$ref\n            ? getSchemaByRef((newSchema.properties[propertyName].items as any).$ref as string)\n            : newSchema.properties[propertyName].items\n\n          ;(newSchema.properties[propertyName].items as any) = {\n            ...newSchema.properties[propertyName].items,\n            ...definedSchema\n          }\n\n          newSchema.properties[propertyName].items = checkSchemaForRefs(newSchema.properties[propertyName].items as ISchemaObject)\n        }\n\n        if (newSchema.properties[propertyName].type === 'object') {\n          newSchema.properties[propertyName] = checkSchemaForRefs(newSchema.properties[propertyName] as ISchemaObject)\n        }\n      })\n    }\n\n    // unref conditions\n    (newSchema.allOf || []).forEach(condition => {\n      if (condition.then && condition.then.properties) {\n        condition.then = checkSchemaForRefs(condition.then)\n      }\n    })\n\n    if (newSchema.then && newSchema.then.properties) {\n      newSchema.then = checkSchemaForRefs(newSchema.then)\n    }\n\n    return newSchema\n  }\n\n  const definitions : any = schema.definitions || {}\n  const definitionNames = Object.keys(definitions)\n  const dereferencedSchema = checkSchemaForRefs(schema)\n\n  delete dereferencedSchema.definitions\n\n  return dereferencedSchema\n}\n","<template>\n  <div id=\"app\">\n    <JsonSchema\n      class=\"schema\"\n      :schema=\"schema\"\n      :ui-schema=\"uiSchema\"\n      v-model=\"value\"\n    />\n    <pre>{{ formattedValue }}</pre>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator'\nimport JsonSchema from './JsonSchema'\n\nconst schema = {\n  type: 'object',\n  properties: {\n    aaa: { type: 'number', maximum: 10 },\n    arr: {\n      type: 'array',\n      items: { type: 'object', properties: { a: { type: 'string', minLength: 2 }, b: { type: 'boolean' } } }\n    },\n    bbb: { type: 'boolean' },\n    ccc: { type: 'string', enum: ['1', '2', '3'] },\n    ddd: {\n      type: 'object',\n      title: '',\n      properties: {\n        a1: { type: 'string', minLength: 1, maxLength: 5 },\n        b2: { type: 'boolean', default: true },\n        ddd: {\n          type: 'object',\n          properties: {\n            a1: { type: 'string', default: 'aaa' },\n            b2: { type: 'boolean' }\n          }\n        }\n      }\n    }\n  },\n  if: {\n    properties: {\n      aaa: {\n        const: 10\n      }\n    }\n  },\n  then: {\n    properties: {\n      newField: { type: 'string' }\n    }\n  }\n}\n\n@Component({\n  name: 'App',\n  components: { JsonSchema }\n})\nexport default class App extends Vue {\n  get schema () {\n    return schema\n  }\n\n  uiSchema = {\n    properties: {\n      ccc: { order: 1, uiType: 'radio', disabled: true },\n      ddd: {\n        properties: {\n          b2: { order: 2 },\n          ddd: { order: 1 }\n        }\n      }\n    }\n  }\n\n  value = {\n    arr: [{ a: 'qwerty', b: true }],\n    aaa: '123asd',\n    bbb: true,\n    ccc: 3\n  }\n\n  get formattedValue () : string {\n    return JSON.stringify(this.value, null, 2)\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #2c3e50;\n  display: flex;\n  padding: 20px 0;\n}\n\n.schema {\n  margin-right: 100px;\n  width: 400px!important;\n}\n</style>\n","import Vue from 'vue'\nimport App from './App.vue'\n\nVue.config.productionTip = false\n\nnew Vue({\n  render: h => h(App)\n}).$mount('#app')\n"],"names":["const","processSchema","schema","strippedSchema","Object","type","properties","entries","forEach","ref","propName","propSchema","items","_typeof","obj","Symbol","iterator","constructor","prototype","defineProperty","exports","value","root","window","global","withParams","vuelidate","paramsOrClosure","maybeValidator","undefined","_default","require$$0","enumerable","get","_withParams","default","__esModule","req","Array","isArray","length","Date","isNaN","getTime","_","String","keys","reference","vm","parentVm","call","expr","test","map","set","_common","min","len","max","setValidators","validations","property","propertyObject","minLength","minimum","required","maxLength","minValue","maximum","maxValue","$each","Map","Set","clone","src","baseClone","circulars","clones","nodeType","cloneNode","RegExp","from","values","push","create","key","idx","findIndex","i","isObject","item","processSchemaConditions","data","newSchema","allOf","condition","processCondition","if","every","requirment","checkRequierment","applyCondition","then","oneOf","some","let","currentPath","not","currentValue","currentParamName","console","warn","mergeDeep","target","sources","source","shift","assign","getSchemaByRef","refName","substring","lastIndexOf","definitionNames","includes","definitions","dereferencedSchema","checkSchemaForRefs","propertyName","$ref","definedSchema","definedSchema$1","Vue","config","productionTip","render","h","App","$mount"],"mappings":"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"}